<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>model.parts.incentives API documentation</title>
<meta name="description" content="Proof of Stake Incentives â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>model.parts.incentives</code></h1>
</header>
<section id="section-intro">
<h1 id="proof-of-stake-incentives">Proof of Stake Incentives</h1>
<ul>
<li>Calculation of PoS attestation and block proposal rewards and penalties</li>
<li>Calculation of PoS slashing penalties</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Proof of Stake Incentives

* Calculation of PoS attestation and block proposal rewards and penalties
* Calculation of PoS slashing penalties
&#34;&#34;&#34;

import typing

from model.types import Gwei
import model.parts.spec as spec


def policy_attestation_rewards(
    params, substep, state_history, previous_state
) -&gt; typing.Dict[str, Gwei]:
    &#34;&#34;&#34;Attestation Rewards Policy Function
    Derived from https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#get_flag_index_deltas

    Extract from spec:
    ```python
    reward_numerator = base_reward * weight * unslashed_participating_increments
    rewards[index] += Gwei(reward_numerator // (active_increments * WEIGHT_DENOMINATOR))
    ```
    &#34;&#34;&#34;

    # Parameters
    TIMELY_SOURCE_WEIGHT = params[&#34;TIMELY_SOURCE_WEIGHT&#34;]
    TIMELY_TARGET_WEIGHT = params[&#34;TIMELY_TARGET_WEIGHT&#34;]
    TIMELY_HEAD_WEIGHT = params[&#34;TIMELY_HEAD_WEIGHT&#34;]
    WEIGHT_DENOMINATOR = params[&#34;WEIGHT_DENOMINATOR&#34;]

    # State Variables
    base_reward = previous_state[&#34;base_reward&#34;]
    number_of_validators = previous_state[&#34;number_of_validators&#34;]
    number_of_validators_online = previous_state[&#34;number_of_validators_online&#34;]

    # Calculate total source reward
    # All submitted attestations have to match source vote
    source_reward = (TIMELY_SOURCE_WEIGHT / WEIGHT_DENOMINATOR) * base_reward
    # Scale reward by the proportion of validators who also got the attestation in time and correctly
    source_reward *= number_of_validators_online / number_of_validators
    # Aggregation over all online validators; assumes one correct vote per online validator per epoch
    source_reward *= number_of_validators_online

    # Calculate total target reward
    target_reward = (TIMELY_TARGET_WEIGHT / WEIGHT_DENOMINATOR) * base_reward
    # Scale reward by the proportion of validators who also got the attestation in time and correctly
    target_reward *= number_of_validators_online / number_of_validators
    # Aggregation over all online validators; assumes one correct vote per online validator per epoch
    target_reward *= number_of_validators_online

    # Calculate total head reward
    head_reward = (TIMELY_HEAD_WEIGHT / WEIGHT_DENOMINATOR) * base_reward
    # Scale reward by the proportion of validators who also got the attestation in time and correctly
    head_reward *= number_of_validators_online / number_of_validators
    # Aggregation over all online validators; assumes one correct vote per online validator per epoch
    head_reward *= number_of_validators_online

    return {
        &#34;source_reward&#34;: source_reward,
        &#34;target_reward&#34;: target_reward,
        &#34;head_reward&#34;: head_reward,
    }


def policy_attestation_penalties(
    params, substep, state_history, previous_state
) -&gt; typing.Dict[str, Gwei]:
    &#34;&#34;&#34;Attestation Penalties Policy Function
    Validators are penalized for not attesting to the source, target, and head.

    Derived from https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#get_flag_index_deltas

    Extract from spec:
    ```python
    penalties[index] += Gwei(base_reward * weight // WEIGHT_DENOMINATOR)
    ```
    &#34;&#34;&#34;

    # Parameters
    TIMELY_SOURCE_WEIGHT = params[&#34;TIMELY_SOURCE_WEIGHT&#34;]
    TIMELY_TARGET_WEIGHT = params[&#34;TIMELY_TARGET_WEIGHT&#34;]
    TIMELY_HEAD_WEIGHT = params[&#34;TIMELY_HEAD_WEIGHT&#34;]
    WEIGHT_DENOMINATOR = params[&#34;WEIGHT_DENOMINATOR&#34;]

    # State Variables
    base_reward = previous_state[&#34;base_reward&#34;]
    number_of_validators_offline = previous_state[&#34;number_of_validators_offline&#34;]

    # Calculate validating penalties
    validating_penalties = (
        (TIMELY_SOURCE_WEIGHT + TIMELY_TARGET_WEIGHT + TIMELY_HEAD_WEIGHT)
        / WEIGHT_DENOMINATOR
        * base_reward
    )
    # Aggregation over all offline validators
    validating_penalties *= number_of_validators_offline

    return {&#34;validating_penalties&#34;: validating_penalties}


def policy_sync_committee_reward(
    params, substep, state_history, previous_state
) -&gt; typing.Dict[str, Gwei]:
    &#34;&#34;&#34;Sync Committee Reward Policy Function
    Derived from https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#sync-committee-processing

    Extract from spec:
    ```python
    # Compute participant and proposer rewards
    total_active_increments = get_total_active_balance(state) // EFFECTIVE_BALANCE_INCREMENT
    total_base_rewards = Gwei(get_base_reward_per_increment(state) * total_active_increments)
    max_participant_rewards = Gwei(total_base_rewards * SYNC_REWARD_WEIGHT // WEIGHT_DENOMINATOR // SLOTS_PER_EPOCH)
    participant_reward = Gwei(max_participant_rewards // SYNC_COMMITTEE_SIZE)
    proposer_reward = Gwei(participant_reward * PROPOSER_WEIGHT // (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT))
    ```
    &#34;&#34;&#34;

    # Parameters
    SYNC_REWARD_WEIGHT = params[&#34;SYNC_REWARD_WEIGHT&#34;]
    WEIGHT_DENOMINATOR = params[&#34;WEIGHT_DENOMINATOR&#34;]

    # State Variables
    base_reward = previous_state[&#34;base_reward&#34;]
    number_of_validators = previous_state[&#34;number_of_validators&#34;]
    number_of_validators_online = previous_state[&#34;number_of_validators_online&#34;]

    # Calculate total base rewards
    total_base_rewards = base_reward * number_of_validators_online
    # Set sync reward to proportion of total base rewards
    sync_reward = total_base_rewards * SYNC_REWARD_WEIGHT // WEIGHT_DENOMINATOR
    # Scale reward by the percentage of online validators
    sync_reward *= number_of_validators_online / number_of_validators

    return {&#34;sync_reward&#34;: sync_reward}


def policy_block_proposal_reward(
    params, substep, state_history, previous_state
) -&gt; typing.Dict[str, Gwei]:
    &#34;&#34;&#34;Block Proposal Reward Policy Function
    Derived from https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#modified-process_attestation

    Extract from spec:
    ```python
    # Participation flag indices
    participation_flag_indices = []
    if is_matching_head and is_matching_target and state.slot == data.slot + MIN_ATTESTATION_INCLUSION_DELAY:
        participation_flag_indices.append(TIMELY_HEAD_FLAG_INDEX)
    if is_matching_source and state.slot &lt;= data.slot + integer_squareroot(SLOTS_PER_EPOCH):
        participation_flag_indices.append(TIMELY_SOURCE_FLAG_INDEX)
    if is_matching_target and state.slot &lt;= data.slot + SLOTS_PER_EPOCH:
        participation_flag_indices.append(TIMELY_TARGET_FLAG_INDEX)

    # Update epoch participation flags
    proposer_reward_numerator = 0
    for index in get_attesting_indices(state, data, attestation.aggregation_bits):
        for flag_index, weight in get_flag_indices_and_weights():
            if flag_index in participation_flag_indices and not has_flag(epoch_participation[index], flag_index):
                epoch_participation[index] = add_flag(epoch_participation[index], flag_index)
                proposer_reward_numerator += get_base_reward(state, index) * weight

    # Reward proposer
    proposer_reward_denominator = (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT) * WEIGHT_DENOMINATOR // PROPOSER_WEIGHT
    proposer_reward = Gwei(proposer_reward_numerator // proposer_reward_denominator)
    increase_balance(state, get_beacon_proposer_index(state), proposer_reward)
    ```
    &#34;&#34;&#34;

    # Parameters
    WEIGHT_DENOMINATOR = params[&#34;WEIGHT_DENOMINATOR&#34;]
    TIMELY_SOURCE_WEIGHT = params[&#34;TIMELY_SOURCE_WEIGHT&#34;]
    TIMELY_TARGET_WEIGHT = params[&#34;TIMELY_TARGET_WEIGHT&#34;]
    TIMELY_HEAD_WEIGHT = params[&#34;TIMELY_HEAD_WEIGHT&#34;]
    PROPOSER_WEIGHT = params[&#34;PROPOSER_WEIGHT&#34;]

    # State Variables
    base_reward = previous_state[&#34;base_reward&#34;]
    sync_reward = previous_state[&#34;sync_reward&#34;]
    number_of_validators_online = previous_state[&#34;number_of_validators_online&#34;]

    # Calculate block proposer reward
    proposer_reward_numerator = base_reward * (
        TIMELY_SOURCE_WEIGHT + TIMELY_TARGET_WEIGHT + TIMELY_HEAD_WEIGHT
    )
    # Aggregate over all attestations in the epoch
    # Assumes every online validator gets one correct source, target, and head vote per epoch
    proposer_reward_numerator *= number_of_validators_online
    # Normalize by the sum of weights so that proposer rewards are 1/8th of base reward
    proposer_reward_denominator = (
        (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT) * WEIGHT_DENOMINATOR // PROPOSER_WEIGHT
    )
    block_proposer_reward = Gwei(
        proposer_reward_numerator // proposer_reward_denominator
    )

    # Add block proposer reward for including sync committee attestations
    # See https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#sync-committee-processing
    block_proposer_reward += (
        sync_reward * PROPOSER_WEIGHT // (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT)
    )

    return {&#34;block_proposer_reward&#34;: block_proposer_reward}


def policy_slashing(
    params, substep, state_history, previous_state
) -&gt; typing.Dict[str, Gwei]:
    &#34;&#34;&#34;Slashing Policy Function
    Derived from https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#modified-slash_validator

    Extract from spec:
    ```python
    state.slashings[epoch % EPOCHS_PER_SLASHINGS_VECTOR] += validator.effective_balance
    decrease_balance(state, slashed_index, validator.effective_balance // MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR)

    # Apply proposer and whistleblower rewards
    proposer_index = get_beacon_proposer_index(state)
    if whistleblower_index is None:
        whistleblower_index = proposer_index
    whistleblower_reward = Gwei(validator.effective_balance // WHISTLEBLOWER_REWARD_QUOTIENT)
    proposer_reward = Gwei(whistleblower_reward * PROPOSER_WEIGHT // WEIGHT_DENOMINATOR)
    increase_balance(state, proposer_index, proposer_reward)
    increase_balance(state, whistleblower_index, Gwei(whistleblower_reward - proposer_reward))
    ```

    Derived from https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#slashings

    Extract from spec:
    ```python
    def process_slashings(state: BeaconState) -&gt; None:
        epoch = get_current_epoch(state)
        total_balance = get_total_active_balance(state)
        adjusted_total_slashing_balance = min(sum(state.slashings) * PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR, total_balance)
        for index, validator in enumerate(state.validators):
            if validator.slashed and epoch + EPOCHS_PER_SLASHINGS_VECTOR // 2 == validator.withdrawable_epoch:
                increment = EFFECTIVE_BALANCE_INCREMENT  # Factored out from penalty numerator to avoid uint64 overflow
                penalty_numerator = validator.effective_balance // increment * adjusted_total_slashing_balance
                penalty = penalty_numerator // total_balance * increment
                decrease_balance(state, ValidatorIndex(index), penalty)
    ```
    &#34;&#34;&#34;
    # Parameters
    dt = params[&#34;dt&#34;]
    slashing_events_per_1000_epochs = params[&#34;slashing_events_per_1000_epochs&#34;]
    MIN_SLASHING_PENALTY_QUOTIENT = params[&#34;MIN_SLASHING_PENALTY_QUOTIENT&#34;]
    PROPORTIONAL_SLASHING_MULTIPLIER = params[&#34;PROPORTIONAL_SLASHING_MULTIPLIER&#34;]
    EFFECTIVE_BALANCE_INCREMENT = params[&#34;EFFECTIVE_BALANCE_INCREMENT&#34;]
    WHISTLEBLOWER_REWARD_QUOTIENT = params[&#34;WHISTLEBLOWER_REWARD_QUOTIENT&#34;]
    PROPOSER_WEIGHT = params[&#34;PROPOSER_WEIGHT&#34;]
    WEIGHT_DENOMINATOR = params[&#34;WEIGHT_DENOMINATOR&#34;]

    # State Variables
    average_effective_balance = previous_state[&#34;average_effective_balance&#34;]

    # Calculate slashing, whistleblower reward, and proposer reward for a single slashing event
    slashing = Gwei(average_effective_balance // MIN_SLASHING_PENALTY_QUOTIENT)
    whistleblower_reward = Gwei(
        average_effective_balance // WHISTLEBLOWER_REWARD_QUOTIENT
    )
    proposer_reward = Gwei(whistleblower_reward * PROPOSER_WEIGHT // WEIGHT_DENOMINATOR)
    whistleblower_reward = Gwei(whistleblower_reward - proposer_reward)

    # Calculate number of slashing events for current epoch
    number_of_slashing_events = slashing_events_per_1000_epochs / 1000

    # Calculate the individual penalty proportional to total slashings
    # in current time period using `PROPORTIONAL_SLASHING_MULTIPLIER`
    total_balance = spec.get_total_active_balance(params, previous_state)
    adjusted_total_slashing_balance = min(
        slashing * number_of_slashing_events * PROPORTIONAL_SLASHING_MULTIPLIER,
        total_balance
    )
    increment = EFFECTIVE_BALANCE_INCREMENT
    penalty_numerator = average_effective_balance // increment * adjusted_total_slashing_balance
    proportional_penalty = penalty_numerator // total_balance * increment
    
    # Scale penalty by the number of slashing events per epoch
    amount_slashed = (slashing + proportional_penalty) * number_of_slashing_events
    # Scale rewards by the number of slashing events per epoch
    whistleblower_reward *= number_of_slashing_events
    proposer_reward *= number_of_slashing_events

    # The whistleblower and the block proposer who includes the slashing receive a reward
    whistleblower_rewards = whistleblower_reward + proposer_reward

    return {
        &#34;amount_slashed&#34;: amount_slashed * dt,
        &#34;whistleblower_rewards&#34;: whistleblower_rewards * dt,
    }


def update_base_reward(
    params, substep, state_history, previous_state, policy_input
) -&gt; typing.Tuple[str, Gwei]:
    &#34;&#34;&#34;Base Reward State Update Function
    Calculate and update base reward per validator
    &#34;&#34;&#34;
    # Parameters
    dt = params[&#34;dt&#34;]

    # Get base reward per validator
    base_reward_per_validator: Gwei = spec.get_base_reward(params, previous_state)

    # By scaling the base reward by our unit of time dt (in epochs),
    # we can scale all rewards and penalties by the same unit of time
    return &#34;base_reward&#34;, Gwei(base_reward_per_validator) * dt


def update_validating_rewards(
    params, substep, state_history, previous_state, policy_input
) -&gt; typing.Tuple[str, Gwei]:
    &#34;&#34;&#34;Validating Rewards State Update Function
    Calculate and update total validating rewards
    i.e. rewards received for block proposal, attesting, and being a member of sync committee
    &#34;&#34;&#34;
    # State Variables
    block_proposer_reward = previous_state[&#34;block_proposer_reward&#34;]
    sync_reward = previous_state[&#34;sync_reward&#34;]

    source_reward = previous_state[&#34;source_reward&#34;]
    target_reward = previous_state[&#34;target_reward&#34;]
    head_reward = previous_state[&#34;head_reward&#34;]

    base_reward = previous_state[&#34;base_reward&#34;]
    number_of_validators_online = previous_state[&#34;number_of_validators_online&#34;]

    # Calculate total validating rewards
    validating_rewards = (
        block_proposer_reward
        + source_reward
        + target_reward
        + head_reward
        + sync_reward
    )

    # Assert validating rewards should be less than equal to the maximum validating rewards
    max_validating_rewards = number_of_validators_online * base_reward
    assert validating_rewards &lt;= max_validating_rewards

    return &#34;validating_rewards&#34;, validating_rewards</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="model.parts.incentives.policy_attestation_penalties"><code class="name flex">
<span>def <span class="ident">policy_attestation_penalties</span></span>(<span>params, substep, state_history, previous_state) â€‘>Â Dict[str,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Attestation Penalties Policy Function
Validators are penalized for not attesting to the source, target, and head.</p>
<p>Derived from <a href="https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#get_flag_index_deltas">https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#get_flag_index_deltas</a></p>
<p>Extract from spec:</p>
<pre><code class="language-python">penalties[index] += Gwei(base_reward * weight // WEIGHT_DENOMINATOR)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def policy_attestation_penalties(
    params, substep, state_history, previous_state
) -&gt; typing.Dict[str, Gwei]:
    &#34;&#34;&#34;Attestation Penalties Policy Function
    Validators are penalized for not attesting to the source, target, and head.

    Derived from https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#get_flag_index_deltas

    Extract from spec:
    ```python
    penalties[index] += Gwei(base_reward * weight // WEIGHT_DENOMINATOR)
    ```
    &#34;&#34;&#34;

    # Parameters
    TIMELY_SOURCE_WEIGHT = params[&#34;TIMELY_SOURCE_WEIGHT&#34;]
    TIMELY_TARGET_WEIGHT = params[&#34;TIMELY_TARGET_WEIGHT&#34;]
    TIMELY_HEAD_WEIGHT = params[&#34;TIMELY_HEAD_WEIGHT&#34;]
    WEIGHT_DENOMINATOR = params[&#34;WEIGHT_DENOMINATOR&#34;]

    # State Variables
    base_reward = previous_state[&#34;base_reward&#34;]
    number_of_validators_offline = previous_state[&#34;number_of_validators_offline&#34;]

    # Calculate validating penalties
    validating_penalties = (
        (TIMELY_SOURCE_WEIGHT + TIMELY_TARGET_WEIGHT + TIMELY_HEAD_WEIGHT)
        / WEIGHT_DENOMINATOR
        * base_reward
    )
    # Aggregation over all offline validators
    validating_penalties *= number_of_validators_offline

    return {&#34;validating_penalties&#34;: validating_penalties}</code></pre>
</details>
</dd>
<dt id="model.parts.incentives.policy_attestation_rewards"><code class="name flex">
<span>def <span class="ident">policy_attestation_rewards</span></span>(<span>params, substep, state_history, previous_state) â€‘>Â Dict[str,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Attestation Rewards Policy Function
Derived from <a href="https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#get_flag_index_deltas">https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#get_flag_index_deltas</a></p>
<p>Extract from spec:</p>
<pre><code class="language-python">reward_numerator = base_reward * weight * unslashed_participating_increments
rewards[index] += Gwei(reward_numerator // (active_increments * WEIGHT_DENOMINATOR))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def policy_attestation_rewards(
    params, substep, state_history, previous_state
) -&gt; typing.Dict[str, Gwei]:
    &#34;&#34;&#34;Attestation Rewards Policy Function
    Derived from https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#get_flag_index_deltas

    Extract from spec:
    ```python
    reward_numerator = base_reward * weight * unslashed_participating_increments
    rewards[index] += Gwei(reward_numerator // (active_increments * WEIGHT_DENOMINATOR))
    ```
    &#34;&#34;&#34;

    # Parameters
    TIMELY_SOURCE_WEIGHT = params[&#34;TIMELY_SOURCE_WEIGHT&#34;]
    TIMELY_TARGET_WEIGHT = params[&#34;TIMELY_TARGET_WEIGHT&#34;]
    TIMELY_HEAD_WEIGHT = params[&#34;TIMELY_HEAD_WEIGHT&#34;]
    WEIGHT_DENOMINATOR = params[&#34;WEIGHT_DENOMINATOR&#34;]

    # State Variables
    base_reward = previous_state[&#34;base_reward&#34;]
    number_of_validators = previous_state[&#34;number_of_validators&#34;]
    number_of_validators_online = previous_state[&#34;number_of_validators_online&#34;]

    # Calculate total source reward
    # All submitted attestations have to match source vote
    source_reward = (TIMELY_SOURCE_WEIGHT / WEIGHT_DENOMINATOR) * base_reward
    # Scale reward by the proportion of validators who also got the attestation in time and correctly
    source_reward *= number_of_validators_online / number_of_validators
    # Aggregation over all online validators; assumes one correct vote per online validator per epoch
    source_reward *= number_of_validators_online

    # Calculate total target reward
    target_reward = (TIMELY_TARGET_WEIGHT / WEIGHT_DENOMINATOR) * base_reward
    # Scale reward by the proportion of validators who also got the attestation in time and correctly
    target_reward *= number_of_validators_online / number_of_validators
    # Aggregation over all online validators; assumes one correct vote per online validator per epoch
    target_reward *= number_of_validators_online

    # Calculate total head reward
    head_reward = (TIMELY_HEAD_WEIGHT / WEIGHT_DENOMINATOR) * base_reward
    # Scale reward by the proportion of validators who also got the attestation in time and correctly
    head_reward *= number_of_validators_online / number_of_validators
    # Aggregation over all online validators; assumes one correct vote per online validator per epoch
    head_reward *= number_of_validators_online

    return {
        &#34;source_reward&#34;: source_reward,
        &#34;target_reward&#34;: target_reward,
        &#34;head_reward&#34;: head_reward,
    }</code></pre>
</details>
</dd>
<dt id="model.parts.incentives.policy_block_proposal_reward"><code class="name flex">
<span>def <span class="ident">policy_block_proposal_reward</span></span>(<span>params, substep, state_history, previous_state) â€‘>Â Dict[str,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Block Proposal Reward Policy Function
Derived from <a href="https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#modified-process_attestation">https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#modified-process_attestation</a></p>
<p>Extract from spec:</p>
<pre><code class="language-python"># Participation flag indices
participation_flag_indices = []
if is_matching_head and is_matching_target and state.slot == data.slot + MIN_ATTESTATION_INCLUSION_DELAY:
    participation_flag_indices.append(TIMELY_HEAD_FLAG_INDEX)
if is_matching_source and state.slot &lt;= data.slot + integer_squareroot(SLOTS_PER_EPOCH):
    participation_flag_indices.append(TIMELY_SOURCE_FLAG_INDEX)
if is_matching_target and state.slot &lt;= data.slot + SLOTS_PER_EPOCH:
    participation_flag_indices.append(TIMELY_TARGET_FLAG_INDEX)

# Update epoch participation flags
proposer_reward_numerator = 0
for index in get_attesting_indices(state, data, attestation.aggregation_bits):
    for flag_index, weight in get_flag_indices_and_weights():
        if flag_index in participation_flag_indices and not has_flag(epoch_participation[index], flag_index):
            epoch_participation[index] = add_flag(epoch_participation[index], flag_index)
            proposer_reward_numerator += get_base_reward(state, index) * weight

# Reward proposer
proposer_reward_denominator = (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT) * WEIGHT_DENOMINATOR // PROPOSER_WEIGHT
proposer_reward = Gwei(proposer_reward_numerator // proposer_reward_denominator)
increase_balance(state, get_beacon_proposer_index(state), proposer_reward)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def policy_block_proposal_reward(
    params, substep, state_history, previous_state
) -&gt; typing.Dict[str, Gwei]:
    &#34;&#34;&#34;Block Proposal Reward Policy Function
    Derived from https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#modified-process_attestation

    Extract from spec:
    ```python
    # Participation flag indices
    participation_flag_indices = []
    if is_matching_head and is_matching_target and state.slot == data.slot + MIN_ATTESTATION_INCLUSION_DELAY:
        participation_flag_indices.append(TIMELY_HEAD_FLAG_INDEX)
    if is_matching_source and state.slot &lt;= data.slot + integer_squareroot(SLOTS_PER_EPOCH):
        participation_flag_indices.append(TIMELY_SOURCE_FLAG_INDEX)
    if is_matching_target and state.slot &lt;= data.slot + SLOTS_PER_EPOCH:
        participation_flag_indices.append(TIMELY_TARGET_FLAG_INDEX)

    # Update epoch participation flags
    proposer_reward_numerator = 0
    for index in get_attesting_indices(state, data, attestation.aggregation_bits):
        for flag_index, weight in get_flag_indices_and_weights():
            if flag_index in participation_flag_indices and not has_flag(epoch_participation[index], flag_index):
                epoch_participation[index] = add_flag(epoch_participation[index], flag_index)
                proposer_reward_numerator += get_base_reward(state, index) * weight

    # Reward proposer
    proposer_reward_denominator = (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT) * WEIGHT_DENOMINATOR // PROPOSER_WEIGHT
    proposer_reward = Gwei(proposer_reward_numerator // proposer_reward_denominator)
    increase_balance(state, get_beacon_proposer_index(state), proposer_reward)
    ```
    &#34;&#34;&#34;

    # Parameters
    WEIGHT_DENOMINATOR = params[&#34;WEIGHT_DENOMINATOR&#34;]
    TIMELY_SOURCE_WEIGHT = params[&#34;TIMELY_SOURCE_WEIGHT&#34;]
    TIMELY_TARGET_WEIGHT = params[&#34;TIMELY_TARGET_WEIGHT&#34;]
    TIMELY_HEAD_WEIGHT = params[&#34;TIMELY_HEAD_WEIGHT&#34;]
    PROPOSER_WEIGHT = params[&#34;PROPOSER_WEIGHT&#34;]

    # State Variables
    base_reward = previous_state[&#34;base_reward&#34;]
    sync_reward = previous_state[&#34;sync_reward&#34;]
    number_of_validators_online = previous_state[&#34;number_of_validators_online&#34;]

    # Calculate block proposer reward
    proposer_reward_numerator = base_reward * (
        TIMELY_SOURCE_WEIGHT + TIMELY_TARGET_WEIGHT + TIMELY_HEAD_WEIGHT
    )
    # Aggregate over all attestations in the epoch
    # Assumes every online validator gets one correct source, target, and head vote per epoch
    proposer_reward_numerator *= number_of_validators_online
    # Normalize by the sum of weights so that proposer rewards are 1/8th of base reward
    proposer_reward_denominator = (
        (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT) * WEIGHT_DENOMINATOR // PROPOSER_WEIGHT
    )
    block_proposer_reward = Gwei(
        proposer_reward_numerator // proposer_reward_denominator
    )

    # Add block proposer reward for including sync committee attestations
    # See https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#sync-committee-processing
    block_proposer_reward += (
        sync_reward * PROPOSER_WEIGHT // (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT)
    )

    return {&#34;block_proposer_reward&#34;: block_proposer_reward}</code></pre>
</details>
</dd>
<dt id="model.parts.incentives.policy_slashing"><code class="name flex">
<span>def <span class="ident">policy_slashing</span></span>(<span>params, substep, state_history, previous_state) â€‘>Â Dict[str,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Slashing Policy Function
Derived from <a href="https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#modified-slash_validator">https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#modified-slash_validator</a></p>
<p>Extract from spec:</p>
<pre><code class="language-python">state.slashings[epoch % EPOCHS_PER_SLASHINGS_VECTOR] += validator.effective_balance
decrease_balance(state, slashed_index, validator.effective_balance // MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR)

# Apply proposer and whistleblower rewards
proposer_index = get_beacon_proposer_index(state)
if whistleblower_index is None:
    whistleblower_index = proposer_index
whistleblower_reward = Gwei(validator.effective_balance // WHISTLEBLOWER_REWARD_QUOTIENT)
proposer_reward = Gwei(whistleblower_reward * PROPOSER_WEIGHT // WEIGHT_DENOMINATOR)
increase_balance(state, proposer_index, proposer_reward)
increase_balance(state, whistleblower_index, Gwei(whistleblower_reward - proposer_reward))
</code></pre>
<p>Derived from <a href="https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#slashings">https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#slashings</a></p>
<p>Extract from spec:</p>
<pre><code class="language-python">def process_slashings(state: BeaconState) -&gt; None:
    epoch = get_current_epoch(state)
    total_balance = get_total_active_balance(state)
    adjusted_total_slashing_balance = min(sum(state.slashings) * PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR, total_balance)
    for index, validator in enumerate(state.validators):
        if validator.slashed and epoch + EPOCHS_PER_SLASHINGS_VECTOR // 2 == validator.withdrawable_epoch:
            increment = EFFECTIVE_BALANCE_INCREMENT  # Factored out from penalty numerator to avoid uint64 overflow
            penalty_numerator = validator.effective_balance // increment * adjusted_total_slashing_balance
            penalty = penalty_numerator // total_balance * increment
            decrease_balance(state, ValidatorIndex(index), penalty)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def policy_slashing(
    params, substep, state_history, previous_state
) -&gt; typing.Dict[str, Gwei]:
    &#34;&#34;&#34;Slashing Policy Function
    Derived from https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#modified-slash_validator

    Extract from spec:
    ```python
    state.slashings[epoch % EPOCHS_PER_SLASHINGS_VECTOR] += validator.effective_balance
    decrease_balance(state, slashed_index, validator.effective_balance // MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR)

    # Apply proposer and whistleblower rewards
    proposer_index = get_beacon_proposer_index(state)
    if whistleblower_index is None:
        whistleblower_index = proposer_index
    whistleblower_reward = Gwei(validator.effective_balance // WHISTLEBLOWER_REWARD_QUOTIENT)
    proposer_reward = Gwei(whistleblower_reward * PROPOSER_WEIGHT // WEIGHT_DENOMINATOR)
    increase_balance(state, proposer_index, proposer_reward)
    increase_balance(state, whistleblower_index, Gwei(whistleblower_reward - proposer_reward))
    ```

    Derived from https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#slashings

    Extract from spec:
    ```python
    def process_slashings(state: BeaconState) -&gt; None:
        epoch = get_current_epoch(state)
        total_balance = get_total_active_balance(state)
        adjusted_total_slashing_balance = min(sum(state.slashings) * PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR, total_balance)
        for index, validator in enumerate(state.validators):
            if validator.slashed and epoch + EPOCHS_PER_SLASHINGS_VECTOR // 2 == validator.withdrawable_epoch:
                increment = EFFECTIVE_BALANCE_INCREMENT  # Factored out from penalty numerator to avoid uint64 overflow
                penalty_numerator = validator.effective_balance // increment * adjusted_total_slashing_balance
                penalty = penalty_numerator // total_balance * increment
                decrease_balance(state, ValidatorIndex(index), penalty)
    ```
    &#34;&#34;&#34;
    # Parameters
    dt = params[&#34;dt&#34;]
    slashing_events_per_1000_epochs = params[&#34;slashing_events_per_1000_epochs&#34;]
    MIN_SLASHING_PENALTY_QUOTIENT = params[&#34;MIN_SLASHING_PENALTY_QUOTIENT&#34;]
    PROPORTIONAL_SLASHING_MULTIPLIER = params[&#34;PROPORTIONAL_SLASHING_MULTIPLIER&#34;]
    EFFECTIVE_BALANCE_INCREMENT = params[&#34;EFFECTIVE_BALANCE_INCREMENT&#34;]
    WHISTLEBLOWER_REWARD_QUOTIENT = params[&#34;WHISTLEBLOWER_REWARD_QUOTIENT&#34;]
    PROPOSER_WEIGHT = params[&#34;PROPOSER_WEIGHT&#34;]
    WEIGHT_DENOMINATOR = params[&#34;WEIGHT_DENOMINATOR&#34;]

    # State Variables
    average_effective_balance = previous_state[&#34;average_effective_balance&#34;]

    # Calculate slashing, whistleblower reward, and proposer reward for a single slashing event
    slashing = Gwei(average_effective_balance // MIN_SLASHING_PENALTY_QUOTIENT)
    whistleblower_reward = Gwei(
        average_effective_balance // WHISTLEBLOWER_REWARD_QUOTIENT
    )
    proposer_reward = Gwei(whistleblower_reward * PROPOSER_WEIGHT // WEIGHT_DENOMINATOR)
    whistleblower_reward = Gwei(whistleblower_reward - proposer_reward)

    # Calculate number of slashing events for current epoch
    number_of_slashing_events = slashing_events_per_1000_epochs / 1000

    # Calculate the individual penalty proportional to total slashings
    # in current time period using `PROPORTIONAL_SLASHING_MULTIPLIER`
    total_balance = spec.get_total_active_balance(params, previous_state)
    adjusted_total_slashing_balance = min(
        slashing * number_of_slashing_events * PROPORTIONAL_SLASHING_MULTIPLIER,
        total_balance
    )
    increment = EFFECTIVE_BALANCE_INCREMENT
    penalty_numerator = average_effective_balance // increment * adjusted_total_slashing_balance
    proportional_penalty = penalty_numerator // total_balance * increment
    
    # Scale penalty by the number of slashing events per epoch
    amount_slashed = (slashing + proportional_penalty) * number_of_slashing_events
    # Scale rewards by the number of slashing events per epoch
    whistleblower_reward *= number_of_slashing_events
    proposer_reward *= number_of_slashing_events

    # The whistleblower and the block proposer who includes the slashing receive a reward
    whistleblower_rewards = whistleblower_reward + proposer_reward

    return {
        &#34;amount_slashed&#34;: amount_slashed * dt,
        &#34;whistleblower_rewards&#34;: whistleblower_rewards * dt,
    }</code></pre>
</details>
</dd>
<dt id="model.parts.incentives.policy_sync_committee_reward"><code class="name flex">
<span>def <span class="ident">policy_sync_committee_reward</span></span>(<span>params, substep, state_history, previous_state) â€‘>Â Dict[str,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Sync Committee Reward Policy Function
Derived from <a href="https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#sync-committee-processing">https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#sync-committee-processing</a></p>
<p>Extract from spec:</p>
<pre><code class="language-python"># Compute participant and proposer rewards
total_active_increments = get_total_active_balance(state) // EFFECTIVE_BALANCE_INCREMENT
total_base_rewards = Gwei(get_base_reward_per_increment(state) * total_active_increments)
max_participant_rewards = Gwei(total_base_rewards * SYNC_REWARD_WEIGHT // WEIGHT_DENOMINATOR // SLOTS_PER_EPOCH)
participant_reward = Gwei(max_participant_rewards // SYNC_COMMITTEE_SIZE)
proposer_reward = Gwei(participant_reward * PROPOSER_WEIGHT // (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def policy_sync_committee_reward(
    params, substep, state_history, previous_state
) -&gt; typing.Dict[str, Gwei]:
    &#34;&#34;&#34;Sync Committee Reward Policy Function
    Derived from https://github.com/ethereum/eth2.0-specs/blob/dev/specs/altair/beacon-chain.md#sync-committee-processing

    Extract from spec:
    ```python
    # Compute participant and proposer rewards
    total_active_increments = get_total_active_balance(state) // EFFECTIVE_BALANCE_INCREMENT
    total_base_rewards = Gwei(get_base_reward_per_increment(state) * total_active_increments)
    max_participant_rewards = Gwei(total_base_rewards * SYNC_REWARD_WEIGHT // WEIGHT_DENOMINATOR // SLOTS_PER_EPOCH)
    participant_reward = Gwei(max_participant_rewards // SYNC_COMMITTEE_SIZE)
    proposer_reward = Gwei(participant_reward * PROPOSER_WEIGHT // (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT))
    ```
    &#34;&#34;&#34;

    # Parameters
    SYNC_REWARD_WEIGHT = params[&#34;SYNC_REWARD_WEIGHT&#34;]
    WEIGHT_DENOMINATOR = params[&#34;WEIGHT_DENOMINATOR&#34;]

    # State Variables
    base_reward = previous_state[&#34;base_reward&#34;]
    number_of_validators = previous_state[&#34;number_of_validators&#34;]
    number_of_validators_online = previous_state[&#34;number_of_validators_online&#34;]

    # Calculate total base rewards
    total_base_rewards = base_reward * number_of_validators_online
    # Set sync reward to proportion of total base rewards
    sync_reward = total_base_rewards * SYNC_REWARD_WEIGHT // WEIGHT_DENOMINATOR
    # Scale reward by the percentage of online validators
    sync_reward *= number_of_validators_online / number_of_validators

    return {&#34;sync_reward&#34;: sync_reward}</code></pre>
</details>
</dd>
<dt id="model.parts.incentives.update_base_reward"><code class="name flex">
<span>def <span class="ident">update_base_reward</span></span>(<span>params, substep, state_history, previous_state, policy_input) â€‘>Â Tuple[str,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Base Reward State Update Function
Calculate and update base reward per validator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_base_reward(
    params, substep, state_history, previous_state, policy_input
) -&gt; typing.Tuple[str, Gwei]:
    &#34;&#34;&#34;Base Reward State Update Function
    Calculate and update base reward per validator
    &#34;&#34;&#34;
    # Parameters
    dt = params[&#34;dt&#34;]

    # Get base reward per validator
    base_reward_per_validator: Gwei = spec.get_base_reward(params, previous_state)

    # By scaling the base reward by our unit of time dt (in epochs),
    # we can scale all rewards and penalties by the same unit of time
    return &#34;base_reward&#34;, Gwei(base_reward_per_validator) * dt</code></pre>
</details>
</dd>
<dt id="model.parts.incentives.update_validating_rewards"><code class="name flex">
<span>def <span class="ident">update_validating_rewards</span></span>(<span>params, substep, state_history, previous_state, policy_input) â€‘>Â Tuple[str,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Validating Rewards State Update Function
Calculate and update total validating rewards
i.e. rewards received for block proposal, attesting, and being a member of sync committee</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_validating_rewards(
    params, substep, state_history, previous_state, policy_input
) -&gt; typing.Tuple[str, Gwei]:
    &#34;&#34;&#34;Validating Rewards State Update Function
    Calculate and update total validating rewards
    i.e. rewards received for block proposal, attesting, and being a member of sync committee
    &#34;&#34;&#34;
    # State Variables
    block_proposer_reward = previous_state[&#34;block_proposer_reward&#34;]
    sync_reward = previous_state[&#34;sync_reward&#34;]

    source_reward = previous_state[&#34;source_reward&#34;]
    target_reward = previous_state[&#34;target_reward&#34;]
    head_reward = previous_state[&#34;head_reward&#34;]

    base_reward = previous_state[&#34;base_reward&#34;]
    number_of_validators_online = previous_state[&#34;number_of_validators_online&#34;]

    # Calculate total validating rewards
    validating_rewards = (
        block_proposer_reward
        + source_reward
        + target_reward
        + head_reward
        + sync_reward
    )

    # Assert validating rewards should be less than equal to the maximum validating rewards
    max_validating_rewards = number_of_validators_online * base_reward
    assert validating_rewards &lt;= max_validating_rewards

    return &#34;validating_rewards&#34;, validating_rewards</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#proof-of-stake-incentives">Proof of Stake Incentives</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="model.parts" href="index.html">model.parts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="model.parts.incentives.policy_attestation_penalties" href="#model.parts.incentives.policy_attestation_penalties">policy_attestation_penalties</a></code></li>
<li><code><a title="model.parts.incentives.policy_attestation_rewards" href="#model.parts.incentives.policy_attestation_rewards">policy_attestation_rewards</a></code></li>
<li><code><a title="model.parts.incentives.policy_block_proposal_reward" href="#model.parts.incentives.policy_block_proposal_reward">policy_block_proposal_reward</a></code></li>
<li><code><a title="model.parts.incentives.policy_slashing" href="#model.parts.incentives.policy_slashing">policy_slashing</a></code></li>
<li><code><a title="model.parts.incentives.policy_sync_committee_reward" href="#model.parts.incentives.policy_sync_committee_reward">policy_sync_committee_reward</a></code></li>
<li><code><a title="model.parts.incentives.update_base_reward" href="#model.parts.incentives.update_base_reward">update_base_reward</a></code></li>
<li><code><a title="model.parts.incentives.update_validating_rewards" href="#model.parts.incentives.update_validating_rewards">update_validating_rewards</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>